# 一、加载和执行
## 1.1 脚本的位置
- JavaScript 脚本阻塞页面渲染：
	- 原因：
		- 当浏览器遇到 \<script> 时，会停止处理页面，先下载、处理 JavaScript 代码。此时，页面渲染和用户交互被完全阻塞。
		- 浏览器解析到 \<body> 前，不会渲染页面的任何部分。
		- JavaScript 文件允许并行下载，\<script> 下载外部资源时不会阻塞其他 \<script>，但会阻塞图片、样式表等资源下载。
	- 解决方式：
		- 脚本放在底部
	
## 1.2 组织脚本
- JavaScript 脚本合并，减少 \<script> 外链 JavaScript 文件数量。
	- HTTP 请求会有额外开销，下载单个 100KB 文件理论上比下载四个 25KB 文件快。
- 不要把内嵌脚本跟在 \<link> 之后。
	- 否则，会导致页面阻塞去等待样式表的下载。
	- 确保内嵌脚本在执行时获得最精准的样式信息。

## 1.3 无阻塞的脚本
- 异步加载：defer 和 async
- 动态脚本元素
- Ajax

# 二、数据存取
## 2.1 管理作用域
- 标识符解析：
	- 现象：
		- 在没有优化过的浏览器中，标识符在作用域链的位置越深，解析速度越慢。
		- Chrome 和 Safari4 采用经过优化过的 JavaScript 引擎，就没有这样的性能损失。
		- IE、Firefox2、Safari 3.2 受到严重影响。
	- 解决方式：
		- 如果某个跨作用域的值在函数中被引用超过一次，则存储到局部变量。
		- 现在经过优化的 JavaScript 引擎都可以经过分析代码，用标识符索引的方式进行快速查找。
- 改变作用域链：
	- 现象：
		- with 可以改变执行环境的作用域链，将一个新的变量对象推入作用域链的头部。
		- try-catch 语句中的 catch 在错误时，将异常对象推入一个变量对象并置于作用域的首位。catch 执行完毕时，作用域链恢复开始的状态。
	- 结果：
		- 作用域首尾放入新的变量对象，对该变量对象的解析速度加快。
		- 局部变量位于作用域链第二个变量对象中，解析代价变高。
- 闭包：
	- 现象：
		- 闭包函数会引用作用域链上的对象，当该闭包函数没有被解除引用前，闭包函数的这一条作用域链不会被销毁。
		- 闭包中引用了跨作用域链的标识符，位置在作用域链深处，导致标识符解析性能损失。
		- 作用域上被引用的变量，即便不在该函数执行环境也不能释放，消耗内存。
	- 解决方式：
		- 小心使用闭包。
		- 标识符解析的解决方式。

		
## 2.2 对象成员
- 访问对象成员：
	- 现象：
		- 访问对象成员（属性和方法）的速度比访问字面量或变量要慢，和访问数组速度相近。
		- 对象成员在原型链中位置越深，找到的速度越慢。
		- 优化过的 JavaScript 引擎的新浏览器在此过程表现优异，老浏览器仍存在性能损失。
	- 原因：
		- 解析对象成员的过程与标识符解析的过程类似，沿着原型链。
- 嵌套成员：
	- 现象：
		- 对象成员可能包含其他的对象嵌套，嵌套太深会影响读取速度。
	- 解决方式：
		- 缓存对象成员

## 2.3 总结
- 沿着作用域链进行的标识符查找和沿着原型链的对象成员查找会影响性能。
- 优化过的 JavaScript 引擎基本没有此类的性能损失，老浏览器仍旧存在这一类问题。
- 解决方式是，对多次用到的深处的标识符或对象成员进行缓存。

# 三、DOM 编程
## 3.1 访问和修改 DOM
- 操作 DOM 天生就慢：
	- 现象：
		- 访问和修改 DOM 要付出昂贵的代价
	- 原因：
		- DOM 是一个独立于语言的，用于操作 XML 和 HTML 文档的接口 API。在浏览器中是用 JavaScript 实现的。
		- 浏览器通常把 DOM 和 JavaScript 独立实现。每次 JavaScript 访问 DOM 都伴随着巨大的开销。
		- HTML 集合是以一种实时状态存在，HTML 集合一直与文档保持着连接，每次需要最新信息时都会重新执行查询过程来实时更新。遍历操作数组的速度远快于操作 HTML 集合。
	- 解决方式：
		- 减少访问 DOM，运算尽可能留在 ECMAScript 这一端处理，即使需要访问 DOM 也需要尽量少，将需要重复访问的缓存。
		- innerHTML 和 DOM 原生方法：
			- 旧版本浏览器中 innerHTML 性能优势明显。
			- 基于 WebKit 内核的新版浏览器中，DOM 原生方法略胜一筹。
		- 节点克隆而不是创建新元素，但节点克隆快的不是很明显。
		- 关于 HTML 集合：
			- 将对 HTML 集合需要多次用到的部分缓存到局部变量，而不是缓存 HTML 集合。
			- 若需要多次遍历 HTML 集合，则最好将 HTML 集合深拷贝到数组，然后遍历数组。这样只需要遍历 HTML 集合一次。
		- 需要从多种 DOM API 中选择时，选择高效的 API。 
			- querySelectorAll()：
				- 比 getElement... 系列方法快很多。
				- 不需要组合调用 getElement... 系列方法。
				- 返回一个 NodeList 而不是 HTML 集合，返回的节点不会实时对应文档结构。
			- 遍历 DOM 时，在老版本浏览器中，nextSibling 比 childNode 快。
			- 现代浏览器 API，可以实现一些元素节点和其他节点的过滤，这些 API 执行效率比手动 JavaScript 过滤效率高。 

## 3.2 修改 DOM 样式导致重绘（repaint）和重排（reflow）
- 基本理论：	
	- DOM 树：表示页面 DOM 结构的树。
	- 渲染树：表示 DOM 节点如何显示。
	- 重排：DOM 的变化影响了元素的几何属性，也影响到其他元素的几何属性。浏览器会让渲染树中受到影响的部分失效，并重新构造渲染树。
	- 重绘：完成重排后，浏览器会重新绘制受影响的部分到屏幕。
	- 重排何时发生：
		- 添加或删除 DOM 元素
		- 元素位置改变
		- 元素尺寸改变
		- 内容改变
		- 页面渲染器初始化
		- 浏览器窗口尺寸改变
	- 不影响几何属性的 DOM 变化，只需要重绘不需要重排，因为元素的布局没有改变。
	- 浏览器重排过程的实现：
		- 普通任务，队列化修改并批量执行
		- 可能会不知不觉中执行某些任务，需要强制性立刻执行重排并刷新队列。

		```
		// 以下属性和方法需要返回最新布局信息，因此浏览器需要立即刷新渲染队列
		- offset系列：offsetTop...
		- scroll系列：scrollLeft...
		- client系列：clientLeft...
		- getComputedStyle()
		```
- 重绘和重排代价很昂贵
	- 解决方式：
		- 减少重绘和重排：
			- 减少使用强制刷新渲染队列的 API
			- 合并多次对 DOM 和样式的修改，一次处理掉
			- 批量修改 DOM：2次重排，否则 step2 每次修改都可能需要重排
				1. 使元素脱离文档流
				2. 将其应用多重改变
				3. 将元素带回文档
			- 避免页面中的大部分重排，让重排只影响渲染树一小部分：
				1. 使用绝对位置定位页面上的动画元素，将其脱离文档流
				2. 让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容。
				3. 当动画结束时恢复定位，从而只会下移一次文档的其他元素
			- 减少使用 CSS 伪选择器，会影响性能且占用 CPU。

## 3.3 通过 DOM 事件处理与用户的交互
- 大量元素的事件绑定代价昂贵
	- 解决方式：
		- 事件委托：
			- 事件逐级冒泡并能被父级元素捕获。
			- 只需给外层元素绑定事件处理器，就可以处理子元素上触发的所有事件。

## 3.4 总结
- 操作 DOM 天生就慢
- 解决方式：
	- 将多次操作的 DOM 缓存。
	- 调用高效的 API。
	- 批量操作。（减少重排和事件委托）

# 四、算法和流程控制
## 4.1 循环
- 循环类型：
	- 标准 for 循环
	- while 循环
	- do-while 循环
	- for-in 循环：实际上是用来枚举对象自身的和继承的可枚举的属性，用在数组时是把数组当成对象来看。
- 循环性能：
	- for-in 循环比其他循环明显慢
		- 表现：只有 1/7 左右的速度。
		- 原因：每次迭代会同时搜索实例和原型属性。
- 循环类型和性能无关时：
	- 减少每次迭代处理的事务。
		- arr.length。
		- 倒序循环。
	- 减少迭代的次数。
		- Duff's Device：一次迭代中执行多次迭代。
- forEach()：慢八倍

## 4.2 条件
- switch 和 if-else：
	- 大多数情况下 switch 比 if-else 运行的快。
	- 但只有条件数量很大时才快的明显。
	- 性能差别：当条件增加时，if-else 性能负担增加的程度比 switch 要多。
- 优化 if-else：
	- 目标：最小化到达正确分支前所需要判断的条件数量。
	- 解决方式：
		- 条件语句应该按照概率从大到小排列：概率差别较大时。
		- 二分法嵌套 if-else：当概率比较相近均匀时。
- 查找表：
	- 目的：有大量离散值需要测试时。
	- 解决方式：用数组和普通对象构建查找表。

## 4.3 递归

## 4.4 总结








