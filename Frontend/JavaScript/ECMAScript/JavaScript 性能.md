# 一、加载和执行

# 二、数据存取
## 2.1 管理作用域
- 标识符解析：
	- 现象：
		- 在没有优化过的浏览器中，标识符在作用域链的位置越深，解析速度越慢。
		- Chrome 和 Safari4 采用经过优化过的 JavaScript 引擎，就没有这样的性能损失。
		- IE、Firefox2、Safari 3.2 受到严重影响。
	- 解决方式：
		- 如果某个跨作用域的值在函数中被引用超过一次，则存储到局部变量。
		- 现在经过优化的 JavaScript 引擎都可以经过分析代码，用标识符索引的方式进行快速查找。
- 改变作用域链：
	- 现象：
		- with 可以改变执行环境的作用域链，将一个新的变量对象推入作用域链的头部。
		- try-catch 语句中的 catch 在错误时，将异常对象推入一个变量对象并置于作用域的首位。catch 执行完毕时，作用域链恢复开始的状态。
	- 结果：
		- 作用域首尾放入新的变量对象，对该变量对象的解析速度加快。
		- 局部变量位于作用域链第二个变量对象中，解析代价变高。
- 闭包：
	- 现象：
		- 闭包函数会引用作用域链上的对象，当该闭包函数没有被解除引用前，闭包函数的这一条作用域链不会被销毁。
		- 闭包中引用了跨作用域链的标识符，位置在作用域链深处，导致标识符解析性能损失。
		- 作用域上被引用的变量，即便不在该函数执行环境也不能释放，消耗内存。
	- 解决方式：
		- 小心使用闭包。
		- 标识符解析的解决方式。

		
## 2.2 对象成员
- 访问对象成员：
	- 现象：
		- 访问对象成员（属性和方法）的速度比访问字面量或变量要慢，和访问数组速度相近。
		- 对象成员在原型链中位置越深，找到的速度越慢。
		- 优化过的 JavaScript 引擎的新浏览器在此过程表现优异，老浏览器仍存在性能损失。
	- 原因：
		- 解析对象成员的过程与标识符解析的过程类似，沿着原型链。
- 嵌套成员：
	- 现象：
		- 对象成员可能包含其他的对象嵌套，嵌套太深会影响读取速度。
	- 解决方式：
		- 缓存对象成员

## 2.3 总结
- 沿着作用域链进行的标识符查找和沿着原型链的对象成员查找会影响性能。
- 优化过的 JavaScript 引擎基本没有此类的性能损失，老浏览器仍旧存在这一类问题。
- 解决方式是，对多次用到的深处的标识符或对象成员进行缓存。

# 三、DOM 编程
## 2.1 访问和修改 DOM
- 操作 DOM 天生就慢：
	- 现象：
		- 访问和修改 DOM 要付出昂贵的代价
	- 原因：
		- DOM 是一个独立于语言的，用于操作 XML 和 HTML 文档的接口 API。在浏览器中是用 JavaScript 实现的。
		- 浏览器通常把 DOM 和 JavaScript 独立实现。每次 JavaScript 访问 DOM 都伴随着巨大的开销。
		- HTML 集合是以一种实时状态存在，HTML 集合一直与文档保持着连接，每次需要最新信息时都会重新执行查询过程来实时更新。遍历操作数组的速度远快于操作 HTML 集合。
	- 解决方式：
		- 减少访问 DOM，运算尽可能留在 ECMAScript 这一端处理，即使需要访问 DOM 也需要尽量少，将需要重复访问的缓存。
		- innerHTML 和 DOM 原生方法：
			- 旧版本浏览器中 innerHTML 性能优势明显。
			- 基于 WebKit 内核的新版浏览器中，DOM 原生方法略胜一筹。
		- 节点克隆而不是创建新元素，但节点克隆快的不是很明显。
		- 关于 HTML 集合：
			- 将对 HTML 集合需要多次用到的部分缓存到局部变量，而不是缓存 HTML 集合。
			- 若需要多次遍历 HTML 集合，则最好将 HTML 集合深拷贝到数组，然后遍历数组。这样只需要遍历 HTML 集合一次。
		- 需要从多种 DOM API 中选择时，选择高效的 API。 
			- querySelectorAll()：
				- 比 getElement... 系列方法快很多。
				- 不需要组合调用 getElement... 系列方法。
				- 返回一个 NodeList 而不是 HTML 集合，返回的节点不会实时对应文档结构。
			- 遍历 DOM 时，在老版本浏览器中，nextSibling 比 childNode 快。
			- 现代浏览器 API，可以实现一些元素节点和其他节点的过滤，这些 API 执行效率比手动 JavaScript 过滤效率高。 

## 2.2 修改 DOM 样式导致重绘（repaint）和重排（reflow）
- 基本理论：	
	- DOM 树：表示页面 DOM 结构的树。
	- 渲染树：表示 DOM 节点如何显示。
	- 重排：DOM 的变化影响了元素的几何属性，也影响到其他元素的几何属性。浏览器会让渲染树中受到影响的部分失效，并重新构造渲染树。
	- 重绘：完成重排后，浏览器会重新绘制受影响的部分到屏幕。
	- 重排何时发生：
		- 添加或删除 DOM 元素
		- 元素位置改变
		- 元素尺寸改变
		- 内容改变
		- 页面渲染器初始化
		- 浏览器窗口尺寸改变
	- 不影响几何属性的 DOM 变化，只需要重绘不需要重排，因为元素的布局没有改变。
	- 浏览器重排过程的实现：
		- 普通任务，队列化修改并批量执行
		- 可能会不知不觉中执行某些任务，需要强制性立刻执行重排并刷新队列。

		```
		// 以下属性和方法需要返回最新布局信息，因此浏览器需要立即刷新渲染队列
		- offset系列：offsetTop...
		- scroll系列：scrollLeft...
		- client系列：clientLeft...
		- getComputedStyle()
		```
- 重绘和重排代价很昂贵
	- 解决方式：
		- 减少重绘和重排：
			- 减少使用强制刷新渲染队列的 API
			- 合并多次对 DOM 和样式的修改，一次处理掉
			- 批量修改 DOM：2次重排，否则 step2 每次修改都可能需要重排
				1. 使元素脱离文档流
				2. 将其应用多重改变
				3. 将元素带回文档
			- 避免页面中的大部分重排，让重排只影响渲染树一小部分：
				1. 使用绝对位置定位页面上的动画元素，将其脱离文档流
				2. 让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容。
				3. 当动画结束时恢复定位，从而只会下移一次文档的其他元素
			- 减少使用 CSS 伪选择器，会影响性能且占用 CPU。

## 2.3 通过 DOM 事件处理与用户的交互












