# 一、加载和执行
## 1.1 脚本的位置
- JavaScript 脚本阻塞页面渲染：
	- 原因：
		- 当浏览器遇到 \<script> 时，会停止处理页面，先下载、处理 JavaScript 代码。此时，页面渲染和用户交互被完全阻塞。
		- 浏览器解析到 \<body> 前，不会渲染页面的任何部分。
		- JavaScript 文件允许并行下载，\<script> 下载外部资源时不会阻塞其他 \<script>，但会阻塞图片、样式表等资源下载。
	- 解决方式：
		- 脚本放在底部
	
## 1.2 组织脚本
- JavaScript 脚本合并，减少 \<script> 外链 JavaScript 文件数量。
	- HTTP 请求会有额外开销，下载单个 100KB 文件理论上比下载四个 25KB 文件快。
- 不要把内嵌脚本跟在 \<link> 之后。
	- 否则，会导致页面阻塞去等待样式表的下载。
	- 确保内嵌脚本在执行时获得最精准的样式信息。

## 1.3 无阻塞的脚本
- 异步加载：defer 和 async
- 动态脚本元素
- Ajax

# 二、数据存取
## 2.1 管理作用域
- 标识符解析：
	- 现象：
		- 在没有优化过的浏览器中，标识符在作用域链的位置越深，解析速度越慢。
		- Chrome 和 Safari4 采用经过优化过的 JavaScript 引擎，就没有这样的性能损失。
		- IE、Firefox2、Safari 3.2 受到严重影响。
	- 解决方式：
		- 如果某个跨作用域的值在函数中被引用超过一次，则存储到局部变量。
		- 现在经过优化的 JavaScript 引擎都可以经过分析代码，用标识符索引的方式进行快速查找。
- 改变作用域链：
	- 现象：
		- with 可以改变执行环境的作用域链，将一个新的变量对象推入作用域链的头部。
		- try-catch 语句中的 catch 在错误时，将异常对象推入一个变量对象并置于作用域的首位。catch 执行完毕时，作用域链恢复开始的状态。
	- 结果：
		- 作用域首尾放入新的变量对象，对该变量对象的解析速度加快。
		- 局部变量位于作用域链第二个变量对象中，解析代价变高。
- 闭包：
	- 现象：
		- 闭包函数会引用作用域链上的对象，当该闭包函数没有被解除引用前，闭包函数的这一条作用域链不会被销毁。
		- 闭包中引用了跨作用域链的标识符，位置在作用域链深处，导致标识符解析性能损失。
		- 作用域上被引用的变量，即便不在该函数执行环境也不能释放，消耗内存。
	- 解决方式：
		- 小心使用闭包。
		- 标识符解析的解决方式。

		
## 2.2 对象成员
- 访问对象成员：
	- 现象：
		- 访问对象成员（属性和方法）的速度比访问字面量或变量要慢，和访问数组速度相近。
		- 对象成员在原型链中位置越深，找到的速度越慢。
		- 优化过的 JavaScript 引擎的新浏览器在此过程表现优异，老浏览器仍存在性能损失。
	- 原因：
		- 解析对象成员的过程与标识符解析的过程类似，沿着原型链。
- 嵌套成员：
	- 现象：
		- 对象成员可能包含其他的对象嵌套，嵌套太深会影响读取速度。
	- 解决方式：
		- 缓存对象成员

## 2.3 总结
- 沿着作用域链进行的标识符查找和沿着原型链的对象成员查找会影响性能。
- 优化过的 JavaScript 引擎基本没有此类的性能损失，老浏览器仍旧存在这一类问题。
- 解决方式是，对多次用到的深处的标识符或对象成员进行缓存。

# 三、DOM 编程
## 3.1 访问和修改 DOM
- 操作 DOM 天生就慢：
	- 现象：
		- 访问和修改 DOM 要付出昂贵的代价
	- 原因：
		- DOM 是一个独立于语言的，用于操作 XML 和 HTML 文档的接口 API。在浏览器中是用 JavaScript 实现的。
		- 浏览器通常把 DOM 和 JavaScript 独立实现。每次 JavaScript 访问 DOM 都伴随着巨大的开销。
		- HTML 集合是以一种实时状态存在，HTML 集合一直与文档保持着连接，每次需要最新信息时都会重新执行查询过程来实时更新。遍历操作数组的速度远快于操作 HTML 集合。
	- 解决方式：
		- 减少访问 DOM，运算尽可能留在 ECMAScript 这一端处理，即使需要访问 DOM 也需要尽量少，将需要重复访问的缓存。
		- innerHTML 和 DOM 原生方法：
			- 旧版本浏览器中 innerHTML 性能优势明显。
			- 基于 WebKit 内核的新版浏览器中，DOM 原生方法略胜一筹。
		- 节点克隆而不是创建新元素，但节点克隆快的不是很明显。
		- 关于 HTML 集合：
			- HTML 集合一直与文档保持着连接，每次需要信息时，都会重复执行查询。
			- 将对 HTML 集合需要多次用到的部分缓存到局部变量，而不是缓存 HTML 集合。
			- 若需要多次遍历 HTML 集合，则最好将 HTML 集合深拷贝到数组，然后遍历数组。这样只需要遍历 HTML 集合一次。
		- 需要从多种 DOM API 中选择时，选择高效的 API。 
			- querySelectorAll()：
				- 比 getElement... 系列方法快很多。
				- 不需要组合调用 getElement... 系列方法。
				- 返回一个 NodeList 而不是 HTML 集合，返回的节点不会实时对应文档结构。
			- 遍历 DOM 时，在老版本浏览器中，nextSibling 比 childNode 快。
			- 现代浏览器 API，可以实现一些元素节点和其他节点的过滤，这些 API 执行效率比手动 JavaScript 过滤效率高。 

## 3.2 修改 DOM 样式导致重绘（repaint）和重排（reflow）
- 基本理论：	
	- DOM 树：表示页面 DOM 结构的树。
	- 渲染树：表示 DOM 节点如何显示。
	- 重排：DOM 的变化影响了元素的几何属性，也影响到其他元素的几何属性。浏览器会让渲染树中受到影响的部分失效，并重新构造渲染树。
	- 重绘：完成重排后，浏览器会重新绘制受影响的部分到屏幕。
	- 重排何时发生：
		- 添加或删除 DOM 元素
		- 元素位置改变
		- 元素尺寸改变
		- 内容改变
		- 页面渲染器初始化
		- 浏览器窗口尺寸改变
	- 不影响几何属性的 DOM 变化，只需要重绘不需要重排，因为元素的布局没有改变。
	- 浏览器重排过程的实现：
		- 普通任务，队列化修改并批量执行
		- 可能会不知不觉中执行某些任务，需要强制性立刻执行重排并刷新队列。

		```
		// 以下属性和方法需要返回最新布局信息，因此浏览器需要立即刷新渲染队列
		- offset系列：offsetTop...
		- scroll系列：scrollLeft...
		- client系列：clientLeft...
		- getComputedStyle()
		```
- 重绘和重排代价很昂贵
	- 解决方式：
		- 减少重绘和重排：
			- 减少使用强制刷新渲染队列的 API
			- 合并多次对 DOM 和样式的修改，一次处理掉
			- 批量修改 DOM：2次重排，否则 step2 每次修改都可能需要重排
				1. 使元素脱离文档流
				2. 将其应用多重改变
				3. 将元素带回文档
			- 避免页面中的大部分重排，让重排只影响渲染树一小部分：
				1. 使用绝对位置定位页面上的动画元素，将其脱离文档流
				2. 让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容。
				3. 当动画结束时恢复定位，从而只会下移一次文档的其他元素
			- 减少使用 CSS 伪选择器，会影响性能且占用 CPU。

## 3.3 通过 DOM 事件处理与用户的交互
- 大量元素的事件绑定代价昂贵
	- 原因：
		- 每个函数都是对象，都占用内存。
		- 要事先指定所有事件处理器，导致 DOM 访问次数过多。
	- 解决方式：
		- 事件委托：
			- 事件逐级冒泡并能被父级元素捕获。
			- 只需给外层元素绑定事件处理器，就可以处理子元素上触发的所有事件。

## 3.4 总结
- 操作 DOM 天生就慢
- 解决方式：
	- 将多次操作的 DOM 缓存。
	- 调用高效的 API。
	- 批量操作。（减少重排和事件委托）

# 四、算法和流程控制
## 4.1 循环
- 循环类型：
	- 标准 for 循环
	- while 循环
	- do-while 循环
	- for-in 循环：实际上是用来枚举对象自身的和继承的可枚举的属性，用在数组时是把数组当成对象来看。
- 循环性能：
	- for-in 循环比其他循环明显慢
		- 表现：只有 1/7 左右的速度。
		- 原因：每次迭代会同时搜索实例和原型属性。
- 循环类型和性能无关时：
	- 减少每次迭代处理的事务。
		- arr.length。
		- 倒序循环。
	- 减少迭代的次数。
		- Duff's Device：一次迭代中执行多次迭代。
- forEach()：慢八倍

## 4.2 条件
- switch 和 if-else：
	- 大多数情况下 switch 比 if-else 运行的快。
	- 但只有条件数量很大时才快的明显。
	- 性能差别：当条件增加时，if-else 性能负担增加的程度比 switch 要多。
- 优化 if-else：
	- 目标：最小化到达正确分支前所需要判断的条件数量。
	- 解决方式：
		- 条件语句应该按照概率从大到小排列：概率差别较大时。
		- 二分法嵌套 if-else：当概率比较相近均匀时。
- 查找表：
	- 目的：有大量离散值需要测试时。
	- 解决方式：用数组和普通对象构建查找表。

## 4.3 递归
- 调用栈限制：
	- 概念：
		- 浏览器存在最大允许递归调用的栈容量。
		- 超过限制即栈溢出。
	- 解决方式：
		- 迭代
		- Memoization
			- 概念：避免重复工作。
			- 例子：斐波那契数列递归计算。
			- 解决方式：缓存重复使用的计算结果。

## 4.4 总结
- 问题：
	- 循环、条件：不同写法性能也不同。
	- 递归：防止栈溢出。
- 解决方式：采取最好的写法，减少重复计算和操作的次数。

# 五、字符串和正则表达式
## 5.1 字符串连接
- 常用字符串拼接方法：
	1. \+
	2. +=
	3. array.join()
	4. string.concat()
- \+ 和 +=：
	- eg：str += “one” + “two”
	- 运行步骤：
		1. 内存中创建一个临时字符串。
		2. 连接后的字符串 “onetwo” 被赋值给该临时字符串。
		3. 临时字符串与 str 当前的值连接。
		4. 结果赋值给 str。
	- 改进方法：
		- 方法一：
			- str += “one”;
			- str += “two”;
		- 方法二：
			- str = str + “one” + “two”;
			- 等价于 str = ((str + “one”) + “two”;
		- 这两种方法避免了产生临时字符串（步骤中的1、2步），在大多数浏览器中能够提速 10% —— 40%
	- 原因：
		- 先运算 + 再运算 +=。
		- “one” 和 “two” 的拼接运算结果，需要一个内存来存储。
		- 优化方法即不用临时内存，而是直接放在 str 中。
		- 浏览器合并字符串时分配内存的方法为：除 IE，其他浏览器都为表达式左侧的字符串分配更多的内存，然后简单的将第二个字符串拷贝至它的末尾。
- Array.prototype.join：
	- 性能：
		- 大多数浏览器中，比其他所有字符串连接方法更慢。
		- 但在 IE 7 及更早版本浏览器中合并大量字符串性能很高（IE 7 已经很少有人用了，原理不理解也没太大关系）
- String.prototype.concat：
	- 性能：
		- 比简单的 + 和 += 稍慢，尤其在 IE、Opera 和 Chrome 中慢的更明显。
		- 若使用 concat 连接字符串数组，比 array.join 方法还要慢一点，潜伏着灾难性问题（像IE 7- 中使用 + 来构建大字符串一样）

## 5.2 正则表达式优化
- 核心：如何优雅正确的使用正则表达式
- 正则表达式工作原理
	1. 编译：
		- 当创建了一个正则表达式对象（使用正则直接量或 RegExp 构造函数），浏览器会验证表达式，然后转化为一个原生代码程序，用于执行匹配工作。
		- 如果把正则对象赋值给一个变量保存下来，可避免重复执行这一步骤。
	2. 设置起始位置：
		- 确定目标字符串的起始搜索位置。
		- 浏览器厂商正在优化正则表达式引擎，提出了很多方法
	3. 匹配每个正则表达式字元
	4. 匹配成功或失败：
		- 如果在字符串当前位置发现了一个完全匹配，那么正则表达式宣布匹配成功。
		- 如果所有可能路径都没有匹配到，那正则表达式引擎回退第二步，从下一个字符作为起始位置开始重新尝试。
		- 当字符串每个字符（包括最后一个字符串后面的位置）都经历了这个过程还没有成功，就彻底宣布匹配失败。
- 匹配的核心算法：回溯
	- 回溯：
		- 概述：
			- 在包含问题的所有解的解空间树中，按照深度优先的策略进行搜索解。
			- 正则表达式的核心与低效之源。
		- 算法：
			- 从根结点出发搜索解空间树。搜索至任一结点时，若不包含解则向其祖父节点回溯。
			- 否则，进入子树递归搜索。
		- 结束条件：
			- 用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。
			- 用来求问题的任一解时，只要搜索到问题的一个解就可以结束。
	- 搜索类型：
		- 贪婪：默认，搜索尽可能长的解，+、*。
		- 惰性：搜索尽可能短的解，？。
- 回溯失控：
	- 例子：一个 HTML 没有写 \</html> 导致正则表达式性能消耗过大。
	- 概念：当正则表达式使用了“.”等概括过广的匹配符且字符串中找不到一些子字符串时，过多的回溯决策选择导致查找性能消耗过大。
	- 解决方案：
		- 谨慎而尽可能具体的书写正则表达式。比如：
			- 将“.”代替为“\S”等更具体一些的描述符。
			- 小心使用嵌套量词，可能会在内部量词和外部量词之间产生一大堆文本拆解路径，导致性能问题。比如：
				- 正确写法：/AA+B/i.exec("AAAAAAAAA")
				- 错误写法：/(A+A+)+B/i.exec("AAAAAAAAA")
			- ...
		- 使用预查和反向引用的模拟原子组。
- 提高正则表达式效率的方法：
	- 关注如何让匹配更快失败
	- 正则表达式以简单、必需的字元开始
	- 使用量词模式，使它们后面的字元互斥
	- 减少分支数量，缩小分支范围
	- 使用非捕获组
	- 只捕获感兴趣的文本以减少后处理
	- 暴露必需的字元
	- 使用合适的量词
	- 把正则表达式赋值给变量并重用它们
	- 将复杂的正则表达式拆分为简单的片段
	- 关注何时不使用正则表达式
		
## 5.3 去除字符串首尾空白
- 背景：ECMAScript 5 添加了原生 trim 方法，但 JavaScript 尚未包含它，对最新浏览器来说，需要手动实现一个 trim 或依赖一个包含此功能的库。
- 方法：**先跳过**，毕竟现代浏览器都提供了相应 trim 方法。有时间再来深入研究。

## 5.4 总结
- 字符串拼接时优先考虑 + 和 +=，但在使用这两个运算符时也要考虑高性能的写法。
- 如何优雅的使用正则表达式。**还需要回顾和理解。**
- trim 方法的手动最佳实现。**还需要回顾和理解。**

# 六、快速响应的用户界面
## 6.1 浏览器 UI 线程
- 浏览器 UI 线程：
	- 概念：用于执行 JavaScript 和更新用户界面的进程。
	- 原理：基于一个简单的队列系统，任务会被保存到队列中直到进程空闲。
- 浏览器限制：
	- 概念：浏览器限制了 JavaScript 任务的运行时间。
	- 需求：确保某些恶意代码不能锁住浏览器。
	- 类型：
		- 调用栈大小限制。
		- 长时间运行脚本限制。

## 6.2 使用定时器让出时间片段
- 目的：每个子任务之间都有一段空闲，避免锁定浏览器给用户带来的糟糕体验。

## 6.3 Web Workers
- Web Workders API：
	- 概念：引入了一个接口，能使代码运行且不占用浏览器 UI 线程的时间。
	- 缺点：没有绑定 UI 线程，不能访问浏览器许多资源，比如 DOM。
	- 运行环境：
		- 一个 navigator 对象，包含四个属性：appName、appVersion、user Agent、platform。
		- 一个 location 对象，与 window.location 相同，不过所有属性都是只读的。
		- 一个 self 对象，指向全局 worker 对象。
		- 一个 importScripts()，阻塞式加载 Worker 用到的外部 JavaScript 文件。
		- 所有 ECMAScript 对象。
		- XMLHttpRequest。
		- setTimeout() 和 setInterval()。
		- 一个 close()，用于停止 Worker 运行。
	- 使用：
		- 代码一旦执行，将为文件创建一个新的线程和新的 Worker 运行环境，该文件被异步下载，直到文件被下载完成后 Worker 开始发挥作用。

		```
		var worker = new Worker("code.js");
		```
- 与 Worker 通信：
	- 通过事件接口通信：
		- postMessage()：传输数据。
		- onmessage()：接受数据。
- 应用：
	- 适用场景：处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。
	- example：
		- 编码、解码大字符串。
		- 复杂数学运算（包括图像或视频处理）。
		- 大数组排序。

## 6.4 总结
- 高效管理浏览器 UI 线程，任何任务不该超过 100 ms。
- 方法：
	- 定时器分割大任务。
	- Web Workers。













