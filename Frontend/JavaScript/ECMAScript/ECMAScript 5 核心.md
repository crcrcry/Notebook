# 一、简介
1. JavaScript
	1. 核心：ECMAScript
	2. 文档对象模型：DOM
	3. 浏览器对象模型：BOM
2. ECMAScript 是一种通过 ECMA-262 标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMA-262 标准的实现和扩展。


# 二、语法
1. for-in：用于枚举对象的属性。in 操作符也可单独使用。
2. label：添加标签，将来使用。
3. 函数参数：存储于arguments对象，命名的参数只提供便利。但二者同步。

# 三、变量
1. ECMAScript 变量有两种类型：
	1. 基本类型：undefined, null, boolean, number, string
	2. 引用类型：object
2. 复制变量值时：
	1. 基本类型：值传递，栈中创建新值。
	2. 引用类型：复制指针。
3. typeof：检测基本数据类型
4. instanceof：检测引用类型

# 四、执行环境与作用域
## 4.1 核心概念
1. 执行环境：execution context，一个函数域或全局域中，代码执行时相应创建的环境。
2. 变量对象：variable object：
	- 函数参数。
	- 环境中定义的所有变量和函数（提前声明机制）。
3. 作用域链：scope chain，变量对象链：
	- 函数定义时，会创建一个预先包含定义该函数的变量对象的作用域链，存于函数的内部属性[[scope]]中，所以作用域链不是只有一条。
	- 函数调用时，为函数创建执行环境，通过复制函数的[[scope]]属性中的对象构建**执行环境的作用域链**，再创建变量对象作为活动对象，推入执行环境作用域链前端。
	- 作用域链本质上是一个指向变量对象的指针列表，只引用但不实际包含变量对象。
4. 活动对象：activation object，作用域上正在被执行和引用的变量对象。
5. 标志符解析：沿着作用域链一级一级搜索标志符，从前端向后回溯，找到为止。

## 4.2 延长作用域链
1. 理念：在作用域链的前端临时增加一个变量对象，代码执行后该变量对象被移除。
2. 方式：
	1. try-catch 中的 catch 块：创建一个新的变量对象，包含的是被抛出的错误对象的声明。
	2. with：将指定的对象添加到作用域链中。

## 4.3 垃圾收集
1. 标记清除
	- 较为常用。
	- 变量进入执行环境时，标记为“进入环境”。不能释放这种变量的内存，因为执行流在该环境中可能用到这些变量。
	- 变量离开环境时，标记为“离开环境”。删除离开环境的变量。
2. 引用计数
	- 不常用。
	- 跟踪每个值被引用的次数，引用次数变成0时释放内存。
	- 问题：循环引用。

# 五、Function 类型
## 5.1 函数内部属性
1. arguments：函数参数。
	1. callee属性：指向拥有这个arguments对象的函数
2. this：函数据以执行的环境对象。
3. caller：调用此函数的对象，不可写。

## 5.2 函数属性和方法
1. length和prototype
2. apply()和call()：在特定作用域中调用函数
	1. apply的参数是：作用域、参数数组
	2. call的参数是：作用域、所有参数枚举
3. bind()：创建函数实例，并将this绑定到传给bind()的参数。

# 六、对象
## 6.1 特性
1. 特性：描述了对象属性（属性分两种）的各种特征，为实现 JavaScript 引擎而产生，不能直接访问，放在两对方括号中。
	1. 数据属性，包含数据值的属性，有4个特性：
		1. [[ Configurable ]]
		2. [[ Enumberable ]]
		3. [[ Writable ]]
		4. [[ Value ]]
	2. 访问器属性，不包含数据值的属性，有4个特性：
		1. [[ Configurable ]]
		2. [[ Enumerable ]] 
		3. [[ Get ]]
		4. [[ Set ]]
2. 操作特性：
	1. 修改属性的特性：Object.defineProperty()
	2. 读取属性的特性：Object.getOwnPropertyDescriptor()
3. delete 操作符，可以删除对象的属性


## 6.2 创建对象
1. 工厂模式：
	1. 通过一个函数工厂化生产和返回对象。
	2. 缺点：无法解决对象识别问题，instanceof无法确定对象类型。
2. 构造函数模式：利用 new 操作符。
	1. 实际步骤：
		1. 创建一个新对象
		2. 将构造函数的作用域赋给新对象（this 指向新对象）
		3. 执行构造函数中的代码（为对象添加属性）
		4. 返回新对象
	2. 缺点：对象中的方法会被重复创建
3. 原型模式：
	1. 所有对象实例共享 prototype 属性包含的属性和方法（指针）。
	2. 重写原型会使对象的 prototype 指针指向新写的原型，但不会改变已创建的对象实例的 prototype 指针。
	2. 在实例中创建同名属性，对原型只会屏蔽不会覆盖。
	3. 搜索对象的属性会从对象本身实例搜索到原型，向上直到找到。
	4. 缺点：原型中包含引用类型的属性，比如 array ，则操作的就是原型对象本身而不会发生同名属性屏蔽。
4. 组合使用构造函数模式和原型模式：解决二者的缺点。
5. 动态原型模式：初次调用时将共享数据加入原型。
6. 寄生构造函数模式：
	1. 类似工厂模式，但使用 new 操作符，且调用的函数叫做构造函数（但返回的对象和构造函数和原型之间，没有关关联）。
	2. 缺点：同工厂模式，且更复杂，不建议使用。
7. 稳妥构造函数模式：没有公共属性，方法不引用 this 对象。适合安全的环境。

## 6.3 继承
1. 原型链是实现继承的主要方法：
	1. 原理：沿着原型链向上搜索。
	2. 缺点：
		1. 引用类型的原型，引用类型共享。
		2. 子类型无法向超类型的构造函数传递参数。
2. 借用构造函数：子类型构造函数的内部调用超类型构造函数。
	1. 优点：
		1. 解决了引用类型共享的问题。因为通过 apply() 或 call() 方法，借调超类型构造函数。就会在子类型的实例中运行超类型构造函数的代码，子类型就会拥有自己的引用类型变量。
		2. 可以传递参数给超类型构造函数。
	2. 缺点：
		1. 方法在构造函数中定义，无法函数复用（函数被重复创建）。
3. 组合继承：将原型链和借用构造函数的技术组合到一起。
	1. 原型链实现对原型属性和方法的继承。
	2. 借用构造函数来实现对实例属性的继承。
4. 原型式继承
5. 寄生式继承
6. 寄生组合式继承

# 七、闭包
## 7.1 闭包
1. 闭包：有权访问另一个函数作用域中的变量的函数。
2. 通常情况：函数内部定义的匿名函数，会将包含函数的变量对象添加到它的作用域链。包含函数执行完毕后，匿名函数被返回，所以包含函数的活动对象不会被销毁（仍然被匿名函数引用）。所以需要手动解除对匿名函数的引用（设置为 null ），以便释放内存。

## 7.2 this 对象
1. 匿名函数的执行环境具有全局性，this 通常指向全局。

## 7.3 模仿块级作用域
```
(function(){
	// code
	// 这里是块级作用域
	// 匿名函数立即执行来模仿块级作用域
})();
```

## 7.4 私有变量
1. 在构造函数内部定义var变量或者构造函数传递变量，然后定义 this.method() 来访问这些变量。
	
## 7.5 静态私有变量
```
// 闭包
(function(){
	// 内部私有变量
	var name = "";
	
	// 全局变量 Person，构造函数
	Person = function(value){
		name = value;
	}
	
	Person.prototype.getName = function(){
		return name;
	}
	
	Person.prototype.setName = function(value){
		name = value;
	}
})();

var person1 = new Person("Hello");
person1.getName();	// Hello
var person2 = new Person("World");
person1.getName();	// World
```
	
# 八、高级技巧
## 8.1 高级函数
1. 安全的类型检测：
	1. 这一技巧用于解决 instanceof 操作符的一些问题：
		1. 多个全局作用域
		2. Json 对象是否原生
	2. 实现方法：
		1. 在 object 上调用原生的 toString()，都会返回一个字符串，显示该对象的构造函数名。
		2. Object.prototype.toString.call(value);  // [object RegExp]
1. 作用域安全的构造函数：
	1. 这一技巧用于解决：
		1. 没有用 new 调用构造函数的情况。
	2. 实现方法：判断 this 是否是构造函数的实例，来正确调用构造函数。
	3. 但在继承时若没有使用原型链（比如，使用借用构造函数），继承可能被破坏。
2. 惰性载入函数	：
	1. 这一技巧用于解决：
		1. 由于浏览器差异，大量 if 语句来检查浏览器能力，导致运行缓慢。
	2. 实现方法：
		1. 函数第一次调用时，将该函数覆盖。
		2. 声明函数时就将函数指定为适当的函数
3. 函数绑定：
	1. 这一技巧用于解决：
		1.  为 JavaScript 提供强大的动态函数创建功能，使函数可以在特定环境运行。
	2. 实现方法：
		1. bind()
4. 函数柯里化：
	1. 这一技巧用于解决：
		1. 为 JavaScript 提供强大的动态函数创建功能。
	2. 实现方法：
		1. 创建已经设置好了一个或多个参数的函数，用闭包返回。
	
## 8.2 防篡改对象
1. 这一技巧用于解决：对象共享，易被篡改。
2. ES5 定义了一些方法，来
	1. 使对象不可拓展
	2. 密封对象
	3. 冻结对象
3. 对象定义为防篡改后，不可撤销。

## 8.3 高级定时器
1. 基本定时器，在一定时间之后将代码加入到队列：
	1. setTimeout()
	2. setInterval()
2. JavaScript 运行机制，单线程环境，JavaScript 中没有任何代码是立刻执行的，而是一旦进程空闲尽快执行：
	1. 主执行进程
	2. 代码队列：进程下一次空闲时执行的代码队列
3. 关于重复定时器 setInterval() 的一些问题
	1. JS引擎，保证队列中只有一段该定时器代码，这确保了定时器代码加入到队列的最小时间间隔为指定间隔。
	2. 问题：
		1. 某些间隔会跳过。
		2. 多个定时器的代码执行间隔可能比预期小。
	3. 解决方案：链式 setTimeout()
4. Yielding Processes
5. 函数节流

## 8.4 自定义事件



## 8.5 拖放
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
