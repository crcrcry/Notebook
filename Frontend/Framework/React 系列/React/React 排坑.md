# 一、排坑
- JSX 默认转义所有字符串，需要 dangerouslySetInnerHTML
- ES6 之后需要手动绑定 this。
	- this 指向调用该函数的作用域。
	- this.setState 中的 this 应该是组件实例的作用域。
	- 两个 this 不一样。
- 单项数据绑定：
	- 父组件传递 props 给子组件，不仅可以传递数据，还可以传递函数。传递数据流只能由父组件给子组件，子组件可以使用父组件传递给子组件的东西，而父组件不能用子组件的东西，即单向绑定中的单向。
	- 绑定是指父组件数据流改变，子组件也能响应的改变。而单向绑定还可以理解成数据可以改变视图、视图不能直接改变数据（需要通过事件）
- 关于默认传递参数：
	- React 事件都会默认传递给绑定的函数一个 event 参数。
	- 关于写法：
		- onChange={this.handleChange}，默认传递 event 参数。
		- onChange={this.handleChange()}，写法不对，onChange 事件是需要绑定一个函数，当触发事件时去执行该函数。这样的写法变成了立即执行 handleChange 函数，将返回值赋值给 onChange 事件。Vue 中不仅可以绑定也可以绑定到内联语句，大概是一个内联语句自动封装的语法糖，不过还挺好用，省去了手动 bind 的过程。
		- 所以使用 bind 和 apply/call 时也需要注意，bind 会默认返回一个绑定了作用域的函数实例，apply/call 会直接调用函数
- 事件触发函数除了 event，能否传递其他参数呢？
	- 大概不能：
		- 因为调用函数并不是我们写的调用的，而是触发事件自动调用，所以不能加函数参数。
		- 事件触发函数绑定的是一个函数的定义啊，定义函数也只能写参数默认值，而不是调用时传值啊。
		- bind 传递参数，箭头函数传递参数，实质上都是在定义函数时写入默认参数罢了。
	- 所以，如果遇到需要写一堆功能类似的函数：
		- 就写一个函数，用 event.target 判断是哪一个触发。
		- 那就写一堆吧，有些封装好的组件（ant design）重写了事件触发，不默认传 event 了就用不了上一个办法了。
			- 用 bind + 设置默认参数来批量创建。
			- 用箭头函数内部调用带参数的函数来批量创建。
			- 反正别傻乎乎的写一堆函数放在 class 里。
- 事件触发时调用的函数为何能够默认传递 event。
	- 事件分发时将 event 传入了 callback。有一个类似 listener(event) 的调用
- 关于自定义组件：
	- 调用封装好的组件时，不要乱加属性，会被当作 props，没被封装过的话就没用了。
	- 所以自定义组件就很好理解了，上面的属性，除了 props 一概没用。在上面监听事件也没用。
	- 根据 Vue 的自定义事件以及 UI 库（antd、antd-mobile）的使用，可以推断出自定义组件上的监听事件的实现原理是：
		- 组件内部自己激发一个自定义事件，在组件标签上监听自定义事件（Vue 中自定义事件就是专门为自定义组件标签服务的，可以且只能在上面监听）。
		- 而传递的参数由组件内部激发函数 emit 带的参数决定。所以通常就不传递默认传递的 event 参数了。

# 二、尚未理解
- React 中，既然自定义组件可以与自定义事件绑定，为何不能写原生事件绑定呢？React 中没有详细的自定义事件的相关说明以及语法糖，参见 Vue，以及我在 Vue 中提出的思考：

	> 	Vue 中，自定义组件既然能监听内部触发的自定义事件，那大概也能监听内部手动触发然后冒泡 or emit 激发的原生事件吧？为何不能自己触发原生事件呢？为何不能将 eg 中的 @click="hh" 自动绑定到 member 里面的最高 div 上呢？涉及到原理了太复杂太复杂。
	>
	> `<member v-on:test="hh" @click="hh"></member>`



