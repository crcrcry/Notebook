# 序言
- 主要是一些我不太熟悉的知识点
- 我比较熟悉的就没有放上来了


# 一、块级绑定
- 重复声明
	- 同一代码块中，禁止重复声明变量
	- 嵌套代码块中，可以重复声明
- 暂时性死区
	- 代码块中，声明之前无法访问变量
- 循环中的代码块
	- for 循环存在三层代码块
		- for 外
		- () 中
		- {} 中
	- 循环中的 let 声明，在每次循环中都创建了一个新的 i 变量。
	- const 可以用在 for...in/of 循环的条件中，但不可以用在传统 for 中。具体要参考 for...in/of 原理。
- 全局块级绑定
	- 在全局作用域，用 var 声明或者直接使用变量都将绑定到全局对象（如：window）上。
	- let、const 不会污染全局对象。
- 最佳实践
	- 默认用 const，要修改用 let。

# 二、字符串和正则表达式
- 对 UTF-16 的支持
	- UTF-16 介绍：
		- 全球唯一标识符（字）被称为代码点，16 位为一个码元。
		- UTF-16 为了支持更大的范围，引入了代理对，即允许两个码元来表示单个代码点。
	- UTF-16 在 ECMAScript 中：
		- ES5 的字符串接口从操作都是基于单码元的。没有考虑双码元。
		- ES6 的接口开始对双码元提供支持。
	- 具体用到的太少，不太熟。

# 三、函数
- 函数参数默认值
	- ES5 中，非严格模式时，arguments 和函数参数直接绑定。严格模式时，更改函数参数不再影响 arguments 对象。
	- ES6 中，arguments 只接受函数调用时传递的参数，不接受默认值。且函数参数与 arguments 不绑定。
	- 参数默认值可以使用表达式，表达式是运行时调用。
	- 关于参数的作用域：
		- 类似 for 中 () 和 {} 的作用域关系。
		- 可以引用其他参数来作为参数默认值，但仅允许前面的参数。原理：暂时性死区，函数参数就类似于创建一个新的 let 标识符绑定。
- 剩余参数：rest parameter
	- 函数的 length 不会计算剩余参数。
	- 一个函数只能有一个 rest，且只能放在最后，且不能在 setter 中使用。
- 拓展运算符
- name 属性
	- 对函数声明和函数表达式都能够支持。
	- 特殊前缀：
		- 使用 bind 创建的函数会有 bound 前缀。
		- 使用 Function 构造器创建的函数会有 anonymous 前缀。
- 函数的双重用途
	- 一个函数有两个内部方法：[[ Call ]] 和 [[ Construct ]]
	- new 和正常调用时分别调用。
	- 判断函数被哪种调用：
		- ES5 中：
			- 如下能解决
			- 但**书上说如果使用 call/apply 能突破这一层（实际好像不能，因为 this 指向 Person 函数，不存在继承）**
			- obj instanceof Object：检测 Object.prototype 是否存在于参数 obj 的原型链上。
		
			```
			function Person(name) {
				if(this instanceof Person) this.name = name;
				else throw new Error('Must use new');
			}
			```
		- ES6 中：


		
		
		
		
		
		
		
		
		